import org.apache.tools.ant.filters.FixCrLfFilter
import java.nio.file.Paths
import java.nio.file.Files

apply plugin: 'com.android.library'
apply from: file(rootProject.file('module.gradle'))

android {
    compileSdkVersion rootProject.ext.targetSdkVersion
    ndkVersion '25.2.9519653'
    
    defaultConfig {
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        externalNativeBuild {
            cmake {
                arguments "-DMODULE_NAME:STRING=$moduleLibraryName"
                // 只编译 ARM 架构，跳过 x86
                abiFilters 'arm64-v8a', 'armeabi-v7a'
            }
        }
        ndk {
            abiFilters 'arm64-v8a', 'armeabi-v7a'
        }
    }

    buildFeatures {
        prefab true
    }

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.22.1"
        }
    }
}

repositories {
    mavenLocal()
}

afterEvaluate {
    android.libraryVariants.forEach { variant ->
        def variantCapped = variant.name.capitalize()
        def variantLowered = variant.name.toLowerCase()

        def zipName = "${magiskModuleId.replace('_', '-')}-${moduleVersion}-${variantLowered}.zip"
        def magiskDir = file("$outDir/magisk_module_$variantLowered")

        task("prepareMagiskFiles${variantCapped}", type: Sync) {
            dependsOn("assemble$variantCapped")

            def templatePath = "$rootDir/template/magisk_module"

            into magiskDir
            from(templatePath) {
                exclude 'module.prop'
            }
            from(templatePath) {
                include 'module.prop'
                expand([
                        id         : magiskModuleId,
                        name       : moduleName,
                        version    : moduleVersion,
                        versionCode: moduleVersionCode.toString(),
                        author     : moduleAuthor,
                        description: moduleDescription,
                ])
                filter(FixCrLfFilter.class,
                        eol: FixCrLfFilter.CrLf.newInstance("lf"))
            }

            // 从编译生成的中间目录获取所有 .so 文件
            from("$buildDir/intermediates/stripped_native_libs/$variantLowered/out/lib") {
                into 'lib'
            }

            doLast {
                // 创建 zygisk 目录
                def zygiskDir = file("$magiskDir/zygisk")
                zygiskDir.mkdirs()

                // 遍历 lib 文件夹下的 ABI 目录 (arm64-v8a, armeabi-v7a)
                fileTree("$magiskDir/lib").visit { f ->
                    if (f.directory) return

                    def abi = f.file.parentFile.name // 获取 arm64-v8a 等
                    
                    if (f.name == "lib${moduleLibraryName}.so") {
                        // 1. 如果是主插件，重命名为 abi.so (如 arm64-v8a.so)
                        Files.move(f.file.toPath(), Paths.get(zygiskDir.absolutePath, "${abi}.so"))
                    } else if (f.name == "libshadowhook.so") {
                        // 2. 如果是 shadowhook 依赖库，保持原名拷贝到 zygisk 目录
                        // 注意：这里需要根据架构分类，但 Zygisk 通常在加载 abi.so 时会搜索同目录
                        def targetDep = file("${zygiskDir.absolutePath}/${f.name}")
                        Files.copy(f.file.toPath(), targetDep.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING)
                    }
                }
                
                // 清理掉临时的 lib 目录
                file("$magiskDir/lib").deleteDir()
            }
        }

        task("zip${variantCapped}", type: Zip) {
            dependsOn("prepareMagiskFiles${variantCapped}")
            from magiskDir
            archiveFileName.set(zipName)
            destinationDirectory.set(outDir)
        }

        // ADB 自动推送和刷入脚本（保持不变）
        task("push${variantCapped}", type: Exec) {
            dependsOn("zip${variantCapped}")
            workingDir outDir
            commandLine android.adbExecutable, "push", zipName, "/data/local/tmp/"
        }

        task("flash${variantCapped}", type: Exec) {
            dependsOn("push${variantCapped}")
            commandLine android.adbExecutable, "shell", "su", "-c",
                    "magisk --install-module /data/local/tmp/${zipName}"
        }

        task("flashAndReboot${variantCapped}", type: Exec) {
            dependsOn("flash${variantCapped}")
            commandLine android.adbExecutable, "shell", "reboot"
        }

        variant.assembleProvider.get().finalizedBy("zip${variantCapped}")
    }
}
